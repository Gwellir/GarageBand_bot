### Текущие пользовательские проблемы

После закрытия бага с обработкой id новых пользователей (перестали влезать в int4 в конце 2021),
остались очень редко проявляющиеся проблемы с пробиванием группового рейт-лимита Telegram,
так как edit_message и delete_message не изменены в кастомном библиотечном MessageQueueBot,
и всегда исполняются немедленно, но учитываются в лимитах.

### Проблемы архитектуры

1. Изначально я предполагал более или менее строго соблюдать модульность бота, и избегать пробрасываний 
лишних внешних данных глубже message_handler(), с целью сохранять возможность без особых
сложностей присоединить, к примеру, адаптер бота другой сети (например, Viber). В самом начале, когда процессоры
и вообще пользовательский ввод ограничивались в основном текстом и изображениями, это делалось бы относительно
тривиально.

    Но (в том числе потому, что я так и не ввёл никакого формата для независимого внутреннего объекта,
соответствующего приходящему сообщению) в итоге часть работы с объектами библиотеки телеграм-бота была на разных
этапах в спешке вписана прямо в процессоры или методы внутренних моделей. Кроме ненужной привязки функциональности,
это привело к тому, что логика работы с внешней сетью разбросана по минимум трём принципиально разным местам,
и её отслеживание усложнилось (а тестирование вообще не особо возможно).

2. Вообще монолитность бота, судя по всему, оказалась ошибкой, так как иногда поднимается вопрос о потенциальной
возможности привязки оформления заявок к формам на сайте (неудивительно, так как бот и заменяет собой
функционал такой формы). Как минимум, бекенд для работы с сохранением и размещением готовых заявок должен быть
отделён, особенно учитывая, что уже написано разветвлённое приложение на Django, осталось только прикрутить API на DRF.

3. В принципе, всё самописное кеширование (модели в обработчике диалогов, словарь данных в заявке) бесполезно
(проблем с производительностью и так не было, не те объёмы). Но создаёт гору мелких проблем с забыванием обработки,
так как в каждом процессоре оно описано индивидуально. Требуется либо унифицировать его, либо применить какое-то
стандартное решение, либо убрать полностью.

4. Божественные объекты/методы - все модели заявок содержат почти все методы (за редким исключением абстракций,
до которых у меня всё же дошли руки), которые повторяются с небольшими изменениями, как минимум, их, вероятно,
стоило бы поделить на тематические менеджеры. Часть методов тоже делает слишком много всего.

5. Данные для инициализации моделей (без которых при развёртывании система не будет работать, например, стадии заявок,
или список областей), содержатся текстом прямо в файлах миграций, в качестве быстрого решения. Скорее всего требуется
выделить их в какой-то внешний формат.

6. Множество строк содержится прямо в коде, и диалоги тоже хранятся в исполняемых скриптах, в принципе, не текстовые 
части из них практически убраны, так что их тоже стоит сложить отдельно (JSON, YAML, локализация?)

7. Система, которая прикидывается state machine (dialog_state_machine, -Stage модели, процессоры) слишком кривая,
и при этом не поддерживает ничего, кроме линейных диалогов (с оговорками, что можно наворотить условные переходы
по списку состояний в процессоре). Нужно иное решение.

   * В python-telegram-bot имеется свой обработчик [ConversationHandler](https://github.com/python-telegram-bot/python-telegram-bot/blob/master/examples/nestedconversationbot.py).
   Теоретически он может поддерживать довольно сложные по структуре диалоги, но при попытке применить его в другом
   проекте, я обнаружил, что он-таки довольно сложно читается и дебажится. 
   * Библиотека aiogram тоже имеет поддержку роутеров диалогов, с учётом состояний и вложенных друг в друга
   отдельных наборов стадий, сейчас я пытаюсь применить его в другом, более простом проекте. Их реализация мне
   нравится гораздо больше, но она (понятно) привязана к телеграму. Плюс в обычной машине состояний стадии
   скорее всего будут конкретными, привязанными ко всему конкретному диалогу, и знающими о его структуре
   достаточно много.
   * Нагуглил несколько продвинутых библиотек для реализации state machine и workflow (это, как я понимаю,
   модель с описанием процесса, который управляет графом состояний, которые сами имеют минимальную информацию
   (и поэтому легко переиспользуются))

8. Нужно поработать над развёртыванием системы, возможно, достаточно просто подглядеть или адаптироваться под
[django-telegram-bot](https://github.com/ohld/django-telegram-bot). 

9. Нужно актуализировать функциональные тесты, и продолжать покрытие кода обычными. Проблемы на деплое пока что
были небольшими, но их всё сложнее быстро отслеживать.